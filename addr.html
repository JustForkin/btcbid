<html>
  <head>
    <script src="bitcoinjs-min.js"></script>
    <script src="bigi.js"></script>
    <script src="buffer.js"></script>

    <script type="text/javascript">

var x;

var CURVE_SIZE = 32;    // Bytes
var CURVE = 'secp256r1';

// pubkey_hex is a bitcoin pubkey in hex
// price and quantity are integers between 0 and 2*32-1
function encrypt_bid(pubkey_hex, price, quantity)
{
    // 0 padded hex price (8 bytes) || quantity (8 bytes)
    msg = ("0000000000000000" + price.toString(16)).slice(-16)
    msg += ("0000000000000000" + quantity.toString(16)).slice(-16)
    // Padding
    msg += "0000000000000000"

    console.log('Encoding message ' + msg);

    // Convert msg into Fp
    m = BigInteger.fromHex(msg)         // BigInteger

    // Get pubkey from hex
    var pubkey = Bitcoin.ECPubKey.fromHex(pubkey_hex)


    // generate random k in F_p
    var k_arr = new Uint8Array(CURVE_SIZE);
    window.crypto.getRandomValues(k_arr);
    // HACK: BigInteger expects a DER encoded string and
    // fromByteArrayUnsigned's wrapper doesn't handle TypedArrays correctly
    if (k_arr[0] & 0x80) {
        var k_arr_hack = new Uint8Array(CURVE_SIZE+1);
        k_arr_hack[0] = 0;
        for (i=0; i<CURVE_SIZE; i++)
            k_arr_hack[i+1] = k_arr[i];
        k_arr = k_arr_hack;
    }
    k = BigInteger.fromByteArrayUnsigned(k_arr);

    // This is the curve we'll use
    ecparam = Bitcoin.sec(CURVE)

    // Calculate C = kP
    var C = ecparam.getG().multiply(k)    // ECPointFp

    // calculate c = x_coord(kY)
    var c = pubkey.Q.multiply(k).x.toBigInteger()    // BigInteger

    // d = c*m mod q
    var d = c.multiply(m).mod(ecparam.getCurve().getQ())    // BigInteger

    return [BigInteger.fromDERInteger(C.getEncoded(1)).toHex(), d.toHex()]
}

function hex2arr(str)
{
    var arr = [];
    for (i=0; i<str.length; i+=2) {
        arr.push(parseInt(str.substr(i, 2), 16))
    }
    //return new Uint8Array(arr);
    return Buffer.Buffer(arr);
}

function decrypt_bid(key, C_hex, d_hex)
{
    ecparam = Bitcoin.sec(CURVE)

    C = Bitcoin.ECPointFp.decodeFrom(ecparam.getCurve(), hex2arr(C_hex))

    // calculate c' = x_coord(xC)

    // m = d/c' mod q

}

function go() {

    var key = Bitcoin.ECKey.makeRandom()

    console.log('-----------------------------------------------')
    console.log('Warning: do NOT use this as a bitcoin address')
    console.log('Market Maker Private key: ' + key.toWIF())
    console.log('Market Maker Public key:  ' + key.pub.toHex())
    console.log('-----------------------------------------------')


    // Alice 10 BTC -> MarketMaker
    //              -> OP_RETURN E_MM(price, quantity, salt)

    var enc = encrypt_bid(key.pub.toHex(), 615, 1);

    console.log('Encrypted to (C, d): ' + enc[0] + ', ' + enc[1])

    // Now decrypt it
    decrypt_bid(key, enc[0], enc[1])
}

window.onload=go;



    </script>
  </head>



  <body>

  </body>

</html>

